<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Fuse Time-Current Curves</title>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <style>
    #readout {
      position: absolute;
      pointer-events: none;
      background: rgba(0,0,0,0.7);
      color: #fff;
      padding: 6px 8px;
      border-radius: 6px;
      font: 12px/1.2 system-ui, sans-serif;
      transform: translate(8px, -8px);
      display: none;
      white-space: nowrap;
    }
    .wrap { position: relative; width: 90%; height: 80vh; margin: 0 auto; }
  </style>
</head>
<body>
  <h2 style="text-align:center;">Fuse Time-Current Curves</h2>

  <div style="text-align:center;margin:20px;">
    <label for="fuseDropdown">Select a Fuse:</label>
    <select id="fuseDropdown"></select>
  </div>

  <div class="wrap">
    <div id="chart" style="width:100%;height:100%;"></div>
    <div id="readout"></div>
  </div>

  <script>
    let cache = {};         // hold active xs/ys/logs for current fuse
    let rafPending = false; // throttle mousemove

    async function loadData() {
      const response = await fetch("fuses.json"); // keep next to this HTML
      const data = await response.json();

      const dropdown = document.getElementById("fuseDropdown");
      Object.keys(data).forEach(fuse => {
        const opt = document.createElement("option");
        opt.value = fuse; opt.text = fuse;
        dropdown.appendChild(opt);
      });

      const first = Object.keys(data)[0];
      plotFuse(first, data);
      dropdown.addEventListener("change", () => plotFuse(dropdown.value, data));
    }

    function prepSeries(xs, ys) {
      // Ensure numeric & monotonic increasing in x (sort pairs if needed)
      const pairs = xs.map((x, i) => [Number(x), Number(ys[i])])
                      .filter(p => isFinite(p[0]) && p[0] > 0 && isFinite(p[1]) && p[1] > 0)
                      .sort((a,b) => a[0]-b[0]);

      const X = pairs.map(p => p[0]);
      const Y = pairs.map(p => p[1]);
      const logX = X.map(v => Math.log10(v));
      const logY = Y.map(v => Math.log10(v));
      return { X, Y, logX, logY };
    }

    function plotFuse(name, data) {
      const xs = (data[name].x || []).map(Number);
      const ys = (data[name].y || []).map(Number);

      cache = prepSeries(xs, ys);
      const { X, Y } = cache;

      const traceLine = {
        x: X, y: Y, mode: "lines", type: "scatter",
        line: { width: 2 },
        hoverinfo: "skip",
        name: name
      };

      const traceMarker = {
        x: [X[0]], y: [Y[0]],
        mode: "markers", type: "scatter",
        marker: { size: 10 },
        hoverinfo: "skip",
        name: "Cursor"
      };

      const layout = {
        title: `Time-Current Curve: ${name}`,
        hovermode: false,
        xaxis: {
          title: "Current (A)",
          type: "log",
          tickmode: "array",
          tickvals: [1,10,100,1000,10000,100000],
          ticktext: ["1","10","100","1k","10k","100k"]
        },
        yaxis: {
          title: "Time (s)",
          type: "log",
          tickvals: [0.0001,0.001,0.01,0.1,1,10,100,1000,10000],
          ticktext: ["0.0001","0.001","0.01","0.1","1","10","100","1k","10k"]
        },
        margin: { l: 70, r: 20, t: 60, b: 60 }
      };

      Plotly.newPlot("chart", [traceLine, traceMarker], layout).then(hookCursor);
    }

    function hookCursor() {
      const gd = document.getElementById("chart");
      const readout = document.getElementById("readout");

      // The inner plot area (SVG) – mouse math should use this bbox
      const plot = gd._fullLayout._plots.xy.plot; // SVG <g> for XY subplot

      function onMove(evt) {
        if (rafPending) return;
        rafPending = true;
        requestAnimationFrame(() => {
          rafPending = false;

          const rect = plot.getBoundingClientRect();
          const xpx = evt.clientX - rect.left;     // pixel X within plot area
          const ypx = evt.clientY - rect.top;      // pixel Y within plot area
          if (xpx < 0 || ypx < 0 || xpx > rect.width || ypx > rect.height) {
            // outside plot area
            Plotly.restyle(gd, { x: [[null]], y: [[null]] }, [1]);
            readout.style.display = "none";
            return;
          }

          const xa = gd._fullLayout.xaxis;
          const ya = gd._fullLayout.yaxis;

          // pixel -> linearized -> data (handles log axes correctly)
          const xlin = xa.p2l(xpx);
          const ylin = ya.p2l(ypx); // not used, but here if you ever want vertical snap
          const xVal = xa.l2d(xlin);

          if (!isFinite(xVal) || xVal <= 0) {
            Plotly.restyle(gd, { x: [[null]], y: [[null]] }, [1]);
            readout.style.display = "none";
            return;
          }

          const { X, Y, logX, logY } = cache;
          if (X.length < 2) return;

          // Find right bracket: first index j where X[j] >= xVal
          let lo = 0, hi = X.length - 1, j = X.length - 1;
          while (lo <= hi) {
            const mid = (lo + hi) >> 1;
            if (X[mid] >= xVal) { j = mid; hi = mid - 1; }
            else { lo = mid + 1; }
          }

          if (j === 0) {
            // left of first point — clamp
            Plotly.restyle(gd, { x: [[X[0]]], y: [[Y[0]]] }, [1]);
            placeReadout(readout, evt, X[0], Y[0]);
            return;
          }
          if (j >= X.length) {
            // right of last point — clamp
            const k = X.length - 1;
            Plotly.restyle(gd, { x: [[X[k]]], y: [[Y[k]]] }, [1]);
            placeReadout(readout, evt, X[k], Y[k]);
            return;
          }

          // Interpolate in log–log space along the segment [j-1, j]
          const lx = Math.log10(xVal);
          const t = (lx - logX[j-1]) / (logX[j] - logX[j-1]);
          const ly = logY[j-1] + t * (logY[j] - logY[j-1]);
          const yVal = Math.pow(10, ly);

          // Update marker
          Plotly.restyle(gd, { x: [[xVal]], y: [[yVal]] }, [1]);

          // Show readout
          placeReadout(readout, evt, xVal, yVal);
        });
      }

      function placeReadout(el, evt, x, y) {
        el.style.display = "block";
        el.style.left = `${evt.clientX}px`;
        el.style.top  = `${evt.clientY}px`;
        el.textContent = `Current: ${fmt(x)} A   •   Time: ${fmt(y)} s`;
      }

      function fmt(v) {
        // pretty: show 3 sig figs, switch to exponential for very small/large
        const a = Math.abs(v);
        if (a >= 1e4 || a < 1e-3) return v.toExponential(2);
        return Number(v).toPrecision(3);
      }

      // attach listeners once
      gd.addEventListener("mousemove", onMove);
      gd.addEventListener("mouseleave", () => {
        Plotly.restyle(gd, { x: [[null]], y: [[null]] }, [1]);
        document.getElementById("readout").style.display = "none";
      });
    }

    loadData();
  </script>
</body>
</html>
