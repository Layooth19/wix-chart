<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Fuse Time-Current Curves</title>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <style>
    .wrap { position: relative; width: 90%; height: 80vh; margin: 0 auto; }
  </style>
</head>
<body>
  <h2 style="text-align:center;">Fuse Time-Current Curves</h2>

  <div style="text-align:center; margin:20px;">
    <label for="fuseDropdown">Select a Fuse:</label>
    <select id="fuseDropdown"></select>
  </div>

  <div class="wrap">
    <div id="chart" style="width:100%;height:100%;"></div>
  </div>

  <div style="text-align:center; margin:20px;">
    <label for="currentInput">Enter Current Rating (A):</label>
    <input type="number" id="currentInput" placeholder="e.g. 10" />
  </div>


  <script>
    const PLOT_CONFIG = {
      responsive: true,
      displayModeBar: true,
      scrollZoom: false,     // stop wheel-zoom
      doubleClick: false,    // stop double-click autorange zoom
    };

    let denseTraceIndex = 1; // index of the dense line trace
    let cursorTraceIndex = 2; // index of the moving marker

    async function loadData() {
      const response = await fetch("fuses.json");
      const data = await response.json();
      window.fuseData = data; // store globally
    
      const dropdown = document.getElementById("fuseDropdown");
      const inputBox = document.getElementById("currentInput");
    
      function populateDropdown(filteredFuses = Object.keys(data)) {
        dropdown.innerHTML = ""; // clear existing options
        filteredFuses.forEach(fuse => {
          const opt = document.createElement("option");
          opt.value = fuse;
          opt.text = fuse;
          dropdown.appendChild(opt);
        });
        if (filteredFuses.length > 0) {
          plotFuse(filteredFuses[0], data);
        }
      }
    
      // Initial population
      populateDropdown();
    
      // Filter dropdown when user inputs a current value
      inputBox.addEventListener("input", () => {
        const inputValue = inputBox.value.trim();
      
        if (inputValue === "") {
          populateDropdown(); // show all fuses
          return;
        }
      
        const targetCurrent = inputValue + "A"; // match fuse name like "10A", "16A", etc.
      
        const filtered = Object.keys(data).filter(fuse => fuse === targetCurrent);
      
        populateDropdown(filtered);
      });
    
      dropdown.addEventListener("change", () => plotFuse(dropdown.value, data));
    }


    function prepSeries(xs, ys) {
      // numeric, positive, sort by x ascending
      const pairs = xs.map((x, i) => [Number(x), Number(ys[i])])
                      .filter(p => isFinite(p[0]) && p[0] > 0 && isFinite(p[1]) && p[1] > 0)
                      .sort((a,b) => a[0]-b[0]);
      const X = pairs.map(p => p[0]);
      const Y = pairs.map(p => p[1]);
      return { X, Y };
    }

    function interpolateLogLog(X, Y, samples = 400) {
      // Build a dense set along log–log space using linear interpolation
      const lx = X.map(v => Math.log10(v));
      const ly = Y.map(v => Math.log10(v));
      const lxMin = lx[0], lxMax = lx[lx.length - 1];
      const denseX = [], denseY = [];

      for (let k = 0; k < samples; k++) {
        const lxq = lxMin + (lxMax - lxMin) * (k / (samples - 1));
        // binary search for segment
        let lo = 0, hi = lx.length - 1, j = lx.length - 1;
        while (lo <= hi) {
          const mid = (lo + hi) >> 1;
          if (lx[mid] >= lxq) { j = mid; hi = mid - 1; }
          else { lo = mid + 1; }
        }
        if (j === 0) {
          denseX.push(Math.pow(10, lx[0]));
          denseY.push(Math.pow(10, ly[0]));
        } else if (j >= lx.length) {
          denseX.push(Math.pow(10, lx[lx.length-1]));
          denseY.push(Math.pow(10, ly[ly.length-1]));
        } else {
          const t = (lxq - lx[j-1]) / (lx[j] - lx[j-1]);
          const lyq = ly[j-1] + t * (ly[j] - ly[j-1]);
          denseX.push(Math.pow(10, lxq));
          denseY.push(Math.pow(10, lyq));
        }
      }
      return { denseX, denseY };
    }

    function plotFuse(name, data) {
      const rawX = (data[name].x || []);
      const rawY = (data[name].y || []);
      const { X, Y } = prepSeries(rawX, rawY);
      const { denseX, denseY } = interpolateLogLog(X, Y, 500);

      // Base (original) line for reference
      const traceOriginal = {
        x: X, y: Y, mode: "lines", type: "scatter",
        line: { width: 2 },
        hoverinfo: "skip",
        name: `${name} (raw)`
      };

      // Dense line: used for smooth hover snapping
      
      const traceDense = {
        x: denseX, y: denseY, mode: "lines", type: "scatter",
        line: { width: 1, color: 'rgba(0,0,0,0)' }, // invisible but hoverable
        hoverinfo: "x+y",
        name: "dense"
      };

      // Cursor marker that we’ll move on hover
      const traceCursor = {
        x: [denseX[0]], y: [denseY[0]],
        mode: "markers", type: "scatter",
        marker: { size: 10 },
        hovertemplate: "Current: %{x}<br>Time: %{y}<extra></extra>",
        name: "cursor"
      };

      // Compute reasonable axis ranges (pad a bit)
      const xMin = Math.min(...X), xMax = Math.max(...X);
      const yMin = Math.min(...Y), yMax = Math.max(...Y);
      
      const layout = {
        title: `Time-Current Curve: ${name}`,
        hovermode: "x unified", // better hover experience
        dragmode: "pan",
        uirevision: name,
        xaxis: {
          title: "Current (A)",
          type: "log",
          range: [Math.log10(xMin) - 0.05, Math.log10(xMax) + 0.05],
          showspikes: false
        },
        yaxis: {
          title: "Time (s)",
          type: "log",
          range: [Math.log10(yMin) - 0.05, Math.log10(yMax) + 0.05],
          showspikes: false
        },
        margin: { l: 70, r: 20, t: 60, b: 60 }
      };


      Plotly.newPlot("chart", [traceOriginal, traceDense, traceCursor], layout, PLOT_CONFIG).then(gd => {
        // Use Plotly's hover events on the dense trace
        gd.on("plotly_hover", ev => {
          const pt = ev.points && ev.points[0];
          if (!pt || pt.curveNumber !== denseTraceIndex) return;
        
          // Update marker position
          Plotly.restyle(gd, { x: [[pt.x]], y: [[pt.y]] }, [cursorTraceIndex]);
        
          // Draw vertical and horizontal lines at marker position
          const shapes = [
            {
              type: 'line',
              xref: 'x',
              x0: pt.x,
              x1: pt.x,
              yref: 'paper',
              y0: 0,
              y1: 1,
              line: {
                color: 'gray',
                width: 1,
                dash: 'dot'
              }
            },
            {
              type: 'line',
              xref: 'paper',
              x0: 0,
              x1: 1,
              yref: 'y',
              y0: pt.y,
              y1: pt.y,
              line: {
                color: 'gray',
                width: 1,
                dash: 'dot'
              }
            }
          ];
        
          Plotly.relayout(gd, { shapes });
        });
        
        gd.on("plotly_unhover", () => {
          // Do nothing — keep marker and lines visible
        });

      });
    }

    loadData();
  </script>
</body>
</html>





